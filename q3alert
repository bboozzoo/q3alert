#!/usr/bin/env python

import pygtk
pygtk.require('2.0')
import sys
import gtk
import gobject
import glib
import gio
import pynotify
import socket
import os
import os.path
import subprocess
from ConfigParser import SafeConfigParser
from io import BytesIO

APPLICATIONS_DIR='/usr/share/applications'
DATA_DIR='/usr/share/q3alert'
ICONS_DIR='/usr/share/pixmaps/q3alert'
CONF_DIR='q3alert'
DESKTOP_FILE='q3alert.desktop'

def singleton(cls):
    """
    signleton decorator function
    """
    instances = {}
    def getinstance():
        if cls not in instances:
            instances[cls] = cls()
        return instances[cls]
    return getinstance

class Q3Error(Exception):
    """error wrapper"""
    pass


class Q3Status(object):
    """
    Q3 status wrapper
    """
    
    def __init__(self, data_map):
        """
        """
        self._data = data_map

    def get(self, key, adapter = None):
        """
        return contents of field
        """
        value = self._data.get(key)

        if not value:
            raise KeyError

        if adapter:
            value = adapter(value)

        return value


class Q3StatusMonitor(gobject.GObject):
    """
    class to handle polling the state and sending notifications
    """
    __gsignals__ = { 
        'status-update' : (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, (object, ))
        }

    def __init__(self, ):
        """
        constructor
        """
        self.__gobject_init__()

        self._conf = Q3StatusConf()
        self._host = self._conf.get('net', 'host')
        self._port = self._conf.get('net', 'port', int)

        self._req_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self._glib_io_tag = None
 

    def _send_status_req(self, ):
        """
        get status from server
        """
        
        if not self._host or \
                not self._port or \
                not self._req_socket:
            return

        if self._glib_io_tag:
            glib.source_remove(self._glib_io_tag)
            self._glib_io_tag = None

        print 'get status'
        request = '\xff\xff\xff\xffgetinfo xxx'

        self._glib_io_tag = glib.io_add_watch(self._req_socket.fileno(), glib.IO_IN, self._data_ready_cb)
        self._req_socket.sendto(request, (self._host, self._port))

    def _data_ready_cb(self, source, condition):
        """
        callback for data ready on request socket
        """
        # fetch data
        response = self._req_socket.recv(2000)
        # handle response
        response_data = response.split('\\')
        #print response_data
        
        # sanity check
        header = response_data[0][4:].strip()
        #print header
        if header != 'infoResponse':
            return None
        
        # skip header
        response_data = response_data[1:]
    
        # check length of remanining parameters - should be even
        # these are key-value pairs
        if len(response_data) % 2 != 0:
            return None
        
        keys = [response_data[i] for i in range(len(response_data)) if i % 2 == 0]
        values = [response_data[i] for i in range(len(response_data)) if i % 2 == 1]
        request_map = dict(zip(keys, values))
        
        self.emit('status-update', Q3Status(request_map))

        # clear source tag
        self._glib_io_tag = None
        # return false to remove from watch
        return False
        

    def poll(self, ):
        """
        """
        self._send_status_req()
        
class Q3StatusUI(gobject.GObject):
    """
    user interface
    """
    
    GAME_READY = 1
    GAME_NOT_READY = 2
    GAME_NOT_READY_POLLING = 3

    __gsignals__ = {
        'quit' : (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, ()),
        'poll-enable-change' : (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, (bool,)),
        'settings-updated' : (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, ()),
        'notification-action' : (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, (object, )),
        'connect' : (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, ())
        }

    __popup_menu = '''
    <ui>
      <popup name="RightClickMenu">
        <menuitem action="Enable" />
        <menuitem action="Settings" />
        <menuitem action="Quit"/>
      </popup>
      <popup name="LeftClickMenu">
        <menuitem action="Connect" />
      </popup>
    </ui>
    '''

    def __init__(self, ):
        """
        constructor
        """
        self.__gobject_init__()
        pynotify.init("Q3 Alert")

        self._config = Q3StatusConf()

        self._init_notifications()

        # build a menu for right click
        self._init_menu()

        # build settings dialog
        self._init_settings_dialog()

        # status (tray) icon
        self._init_icon()

    def _init_notifications(self, ):
        """
        initialize notification support, check server capabilities
        """
        # get capabilities of the server
        server_caps = pynotify.get_server_caps()

        # check if actions are supported
        self._notification_action_support = False
        if filter(lambda x: x == 'actions', server_caps):
            self._notification_action_support = True

        # set the enable notifications flag
        self._enable_notifications = self._config.get('ui', 'notifications', int, 1)
        # holder for notification object
        self._notification = None

        

    def _init_menu(self, ):
        """
        initialize menu for right and left click
        """
        # build UI
        ui = gtk.UIManager()
        rc_actiongroup = gtk.ActionGroup('RightClick')

        rc_actiongroup.add_toggle_actions([('Enable', None, '_Enable polling', None,
                                            'Enable server polling', self._toggle_polling_cb)])

        rc_actiongroup.add_actions([('Quit', gtk.STOCK_QUIT, '_Quit', None,
                                     'Exit program', self._quit_cb),
                                    ('Settings', None, '_Settings', None,
                                     'Show settings', self._show_settings_cb)])

        lc_actiongroup = gtk.ActionGroup('LeftClick')
        lc_actiongroup.add_actions([('Connect', None, '_Connect', None,
                                     'Connect to server', self._server_connect_cb)])

        ui.insert_action_group(rc_actiongroup, 0)
        ui.insert_action_group(lc_actiongroup, 1)

        ui.add_ui_from_string(self.__popup_menu)

        # configure widgets for right click
        self._rc_menu = ui.get_widget('/RightClickMenu')
        self._enable_toggle = ui.get_widget('/RightClickMenu/Enable')

        enabled_status = self._config.get('core', 'enable', int)
        #print 'polling enabled:', enabled_status
        self._enable_toggle.set_property('active', enabled_status)

        # configure widgets for left click
        self._lc_menu = ui.get_widget('/LeftClickMenu')

    def _init_settings_dialog(self, ):
        """
        initialize settings dialog
        """
        builder = gtk.Builder()
        builder.add_from_file(Q3FileRes.get_ui_file('settings-dialog.ui'))
        d = builder.get_object('SettingsDialog')
        d.set_icon_from_file(Q3FileRes.get_icon_file('colored.svg'))

        d.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT)
        # save the button for later use
        # as the button will be disabled if any of the settings is invalid
        self._settings_button_ok = d.add_button(gtk.STOCK_OK, gtk.RESPONSE_ACCEPT)

        self._setting_ip_entry = builder.get_object('IPAddress')
        self._setting_ip_entry.connect('changed', self._setting_ip_entry_changed_cb, self)

        self._setting_port_entry = builder.get_object('Port')
        self._setting_port_entry.connect('changed', self._setting_port_entry_changed_cb, self)

        self._setting_poll_interval = builder.get_object('PollInterval')
        self._setting_poll_interval.set_lower(1)

        self._setting_autostart = builder.get_object('StartAtLogin')

        self._setting_notifications = builder.get_object('ShowNotifications')
        self._setting_notifications.connect('toggled', self._show_notifications_toggled_cb, self)

        self._setting_quake_cmd = builder.get_object('QuakeCmdButton')
        self._setting_quake_cmd_group = builder.get_object('QuakeCmdGroup')
        if self._enable_notifications:
            self._setting_quake_cmd_group.hide_all()
            
        self._settings_dialog = d

    def _show_notifications_toggled_cb(self, button, ui):
        """
        user toggled 'show notifications' button
        show or hide the quake III path button
        Arguments:
        - `button`:
        - `ui`:
        """
        if self._setting_notifications.get_active():
            self._setting_quake_cmd_group.show_all()
        else:
            self._setting_quake_cmd_group.hide_all()

    def _setting_ip_entry_changed_cb(self, entry, ui):
        """
        IP address entry has been changed
        Arguments:
        - `entry`:
        - `ui`:
        """
        pass

    def _setting_port_entry_changed_cb(self, entry, ui):
        """
        port entry has been changed
        Arguments:
        - `entry`:
        - `ui`:
        """
        bad = False
        port = 0
        try:
            port = int(entry.get_text())
        except:
            bad = True

        if not bad:
            if port <= 0 or port >= 65535:
                bad = True

        if bad:
            entry.set_property('secondary-icon-stock', gtk.STOCK_DIALOG_WARNING)
            entry.set_property('secondary-icon-tooltip-text', 'Incorrect port value')
        else:
            entry.set_property('secondary-icon-stock', None)

    def _init_icon(self, ):
        """
        initialize status icon
        """
        # load icons
        self._icon_bw = gtk.gdk.pixbuf_new_from_file(Q3FileRes.get_icon_file('bw.svg'))
        self._icon_color = gtk.gdk.pixbuf_new_from_file(Q3FileRes.get_icon_file('colored.svg'))
        self._icon_bw_polling = gtk.gdk.pixbuf_new_from_file(Q3FileRes.get_icon_file('bw-polling.svg'))
        
        # create status icon
        self._status_icon = gtk.status_icon_new_from_pixbuf(self._icon_bw)

        # connect signals
        self._status_icon.connect('popup-menu', self._show_popup_rc_menu_cb)
        self._status_icon.connect('activate', self._show_popup_lc_menu_cb)

    def set_indicator(self, status, message = None, message_actions = None):
        """
        set notifications and indicators according to status
        Arguments:
        - `indicator`: indicator status
        - `message`: message displayed in indicator
        - `message_actions`: list of tuples (action_id, action_string, callback)
        where action_string is the description show to the user, callback is called upon
        selection of given action
        """
        if status == Q3StatusUI.GAME_READY:
            self._status_icon.set_from_pixbuf(self._icon_color)
        elif status == Q3StatusUI.GAME_NOT_READY:
            self._status_icon.set_from_pixbuf(self._icon_bw)
        elif status == Q3StatusUI.GAME_NOT_READY_POLLING:
            self._status_icon.set_from_pixbuf(self._icon_bw_polling)
        
        # display notification 
        if message:
            self._display_notification(message, message_actions)

    def show(self, ):
        """
        """
        pass

    def _toggle_polling_cb(self, b):
        """
        
        """
        print 'status:', self._enable_toggle.get_active()
        self.emit('poll-enable-change', self._enable_toggle.get_active())

    def _show_popup_rc_menu_cb(self, status_icon, button, activate_time):
        """
        callback for right click
        Arguments:
        - `status_icon`:
        - `button`:
        - `activate_time`:
        """
        if self._rc_menu:
            self._rc_menu.popup(None, None, gtk.status_icon_position_menu, 
                                button, activate_time, status_icon)

    def _show_popup_lc_menu_cb(self, status_icon):
        """
        callback for left click
        Arguments:
        - `status_icon`:
        - `button`:
        - `activate_time`:
        """
        if self._lc_menu:
            self._lc_menu.popup(None, None, gtk.status_icon_position_menu, 
                                1, gtk.get_current_event_time(), status_icon)

    def _update_settings(self, ):
        """
        put new settings into configuration
        """
        ip = self._setting_ip_entry.get_text()
        self._config.set('net', 'host', ip)

        port = self._setting_port_entry.get_text()
        self._config.set('net', 'port', port)

        interval = int(self._setting_poll_interval.get_value())
        self._config.set('core', 'poll_interval', interval)

        autostart = int(self._setting_autostart.get_active())
        self._config.set('core', 'autostart', autostart)

        notifications = int(self._setting_notifications.get_active())
        self._config.set('ui', 'notifications', notifications)
        # set the flag accordingly
        self._enable_notifications = notifications

        # path to quake binary
        quake_path = self._setting_quake_cmd.get_filename()
        if not quake_path:
            quake_path = ''
        self._config.set('app', 'quake_cmd', quake_path)

    def _fill_settings_dialog(self, ):
        """
        fill entries in settings dialog with current values
        """
        self._setting_ip_entry.set_text(self._config.get('net', 'host'))
        self._setting_port_entry.set_text(self._config.get('net', 'port'))
        self._setting_poll_interval.set_value(self._config.get('core', 'poll_interval', int))
        self._setting_autostart.set_active(self._config.get('core', 'autostart', int))
        self._setting_notifications.set_active(self._config.get('ui', 'notifications', int))

        # load path from configuration
        quake_path = None
        try:
            quake_path = self._config.get('app', 'quake_cmd')
            self._setting_quake_cmd.set_filename(quake_path)
        except:
            self._setting_quake_cmd.set_current_name('(None)')

    def _server_connect_cb(self, b):
        """
        user clicked on connect button
        Arguments:
        - `b`:
        """
        self.emit('connect')

    def _show_settings_cb(self, b):
        """
        show settings clicked
        """
        print 'show settings'
        # fill entries in dialog with data
        self._fill_settings_dialog()

        # show dialog, wait for response
        response = self._settings_dialog.run()
        self._settings_dialog.hide()

        # emit signal if user has changed configuration
        if response == gtk.RESPONSE_ACCEPT:
            # update settings if accepted
            self._update_settings()
            # signal that settings need to be saved
            self.emit('settings-updated')
        
    def _quit_cb(self, b):
        """
        quit clicked
        """
        if self._notification:
            self._notification.close()
            self._notification = None
        self.emit('quit')

    def _notification_action_cb(self, n, action):
        """
        action from user - notification popup
        Arguments:
        - `n`:
        - `action`:
        """
        print 'notification', action
        n.close()
        self.emit('notification-action', action)

    def _notification_closed_cb(self, n):
        """
        notification popup was closed
        Arguments:
        - `n`:
        """
        print 'notification closed'
        self._notification = None

    def _display_notification(self, message, actions):
        """
        show a popup notification
        - `message`: notification text
        - `actions`: list of uples (action_id, action_string)
        """
        print 'show notification'
        # show notification only if enabled and previous is already gone
        if self._enable_notifications and \
                not self._notification:
            n = pynotify.Notification('Q3 Alert', message)
            n.connect('closed', self._notification_closed_cb)
            n.set_icon_from_pixbuf(self._icon_color)
            if self._notification_action_support:
                for act in actions:
                    print 'adding action', act[0], 'description:', act[1]
                    n.add_action(act[0], act[1], self._notification_action_cb)
            n.show()
            self._notification = n

    

class Q3StatusApp(gobject.GObject):
    """
    app core
    """
    def __init__(self, ):
        """
        """
        self.__gobject_init__()

        self._game_available = False

        self._conf = Q3StatusConf()
        
        self._UI = Q3StatusUI()
        self._UI.connect('quit', self._ui_quit_cb)
        self._UI.connect('poll-enable-change', self._polling_enable_changed_cb)
        self._UI.connect('settings-updated', self._settings_updated_cb)
        self._UI.connect('notification-action', self._notification_action_cb)
        self._UI.connect('connect', self._server_connect_cb)

        self._monitor = Q3StatusMonitor()
        self._monitor.connect('status-update', self._status_update_cb)

        # load polling settings
        self._setup_polling()
        # load autostart setting
        self._setup_autostart()

    def _setup_polling(self, ):
        """
        setup the polling - reload settings from configuration
        """
        self._poll_interval = self._conf.get('core', 'poll_interval', int)
        self._polling = self._conf.get('core', 'enable', int)
        print 'setup polling, enabled: %d, interval: %d' % (self._polling, self._poll_interval)
        if self._polling:
            self._enable_polling()
        else:
            self._disable_polling()

    def _setup_autostart(self, ):
        """
        initialize autostart part - reload settings from configuration
        """
        user_autostart_dir = os.path.join(glib.get_user_config_dir(), 'autostart')
        user_autostart_file = os.path.join(user_autostart_dir, DESKTOP_FILE)
        application_file = Q3FileRes.get_desktop_file(DESKTOP_FILE)

        self._autostart = self._conf.get('core', 'autostart', int)

        if self._autostart:
            # enable autostart
            if not os.path.exists(user_autostart_file):
                os.symlink(application_file, user_autostart_file)
        else:
            # remove startup file if user does not wish
            # to start the app at login
            if os.path.exists(user_autostart_file):
                os.remove(user_autostart_file)

    def _ui_quit_cb(self, ui):
        """
        UI callback for quit operation
        """
        gtk.main_quit()

    def _status_update_cb(self, q3statusmonitor, status):
        """
        callback for status update from monitor
        """
        print 'status update'
        try:
            clients = status.get('clients', int)
            mapname = status.get('mapname')
            
            print 'clients:', clients, ' mapname:', mapname
            # show notification only once - if there was no game before
            if not self._game_available:
                if clients:
                    self._game_available = True
                    # show notification popup
                    self._notify_user(status)
            else:
                # no game - update the icon
                if not clients:
                    self._game_available = False
                    if self._polling:
                        self._UI.set_indicator(Q3StatusUI.GAME_NOT_READY_POLLING)
                    else:
                        self._UI.set_indicator(Q3StatusUI.GAME_NOT_READY)
        except Exception, e:
            print e

    def _notify_user(self, game_status):
        """
        order UI to show a notification to the user
        about ongoing game
        Arguments:
        - `game_status`: Q3Status - game status
        """
        message = 'Game in progress\n'\
            '%s - %d players' % (game_status.get('mapname'), game_status.get('clients', int))
        actions = []
        action_connect = ('start_quake', 'Connect')

        # show the connect action only if the quake command
        # is an executable file
        try:
            quake_cmd = self._conf.get('app', 'quake_cmd')
            if quake_cmd and \
                    os.path.isfile(quake_cmd) and \
                    os.access(quake_cmd, os.X_OK):
                actions.append(action_connect)
        except:
            pass
        # call the UI indicator, allowing the user to click on 'Connect'
        # to automagically start quake and connect to given server
        self._UI.set_indicator(Q3StatusUI.GAME_READY, message, actions)
        
    def _notification_action_cb(self, ui, action):
        """
        callback for action from notification popup
        Arguments:
        - `action`:
        """
        print 'action', action
        if action == 'start_quake':
            self._start_quake()

    def _server_connect_cb(self, ui):
        """
        callback for connect to server selected by user
        Arguments:
        - `ui`:
        """
        self._start_quake()

    def _start_quake(self, ):
        """
        start quake process as a result of user selection
        """
        print 'starting quake'
        quake_cmd = None
        try:
            quake_cmd = self._conf.get('app', 'quake_cmd')
        except:
            print 'quake command not set'

        if not quake_cmd:
            return

        connection_address = '%s:%d' % (self._conf.get('net', 'host'),
                                        self._conf.get('net', 'port', int))
        
        #subprocess.Popen([quake_cmd, '+connect', connection_address])
        glib.spawn_async([quake_cmd, '+connect', connection_address])
        

    def _poll_timeout_cb(self):
        """
        polling timeout - check server status
        """
        print 'poll timeout'

        # check the state of polling variable
        # it's not possible to remove timeout from events queue (or is it?)
        # hence this workaround
        if self._polling:
            self._monitor.poll()
            self._schedule_poll()

        # always return false, the new timeout is already added
        return False

    def run(self, ):
        """
        enter main loop
        """
        self._UI.show()
        gtk.main()

    def _polling_enable_changed_cb(self, b, status):
        """
        polling status was toggled
        Arguments:
        - `b`:
        - `status`: polling status
        """
        print status
        self._conf.set('core', 'enable', status, int)
        self._settings_updated_cb(None)

    def _enable_polling(self, ):
        """
        enable polling - reload poll interval, set timeout and poll flag
        """
        self._polling = True
        self._schedule_poll()
        if not self._game_available:
            self._UI.set_indicator(Q3StatusUI.GAME_NOT_READY_POLLING)

    def _schedule_poll(self, ):
        """
        add glib timer for polling
        """
        self._poll_interval = self._conf.get('core', 'poll_interval', int)            
        # start polling
        glib.timeout_add_seconds(self._poll_interval, self._poll_timeout_cb) 

    def _disable_polling(self, ):
        """
        disable polling - set polling flag
        """
        self._polling = False
        if not self._game_available:
            self._UI.set_indicator(Q3StatusUI.GAME_NOT_READY)

    def _settings_updated_cb(self, b):
        """
        """
        print 'settings update'
        self._conf.sync()
        # reapply settings
        self._setup_polling()
        self._setup_autostart()

__default_config__ = '''
[core]
poll_interval = 20
enable = 1
autostart = 0

[ui]
notifications = 1

[net]
port = 27960
host = 10.10.16.24

[app]
quake_cmd = 
'''

@singleton
class Q3StatusConf(object):
    """
    configuration wrapper
    """
    
    def __init__(self, ):
        """
        """
        self._config = SafeConfigParser()
        
        conf_dir = os.path.join(glib.get_user_config_dir(), CONF_DIR)
        self._config_path = os.path.join(conf_dir, 'conf')

        if not os.path.exists(conf_dir):
            os.makedirs(conf_dir)
            
        if not os.path.exists(self._config_path):
            self._fill_default_config()

        self._load_config()

    def _load_config(self, ):
        """
        parse configuration file
        """
        # try to load the configuration file
        if os.path.exists(self._config_path):
            self._config.read(self._config_path)

    def _fill_default_config(self, ):
        """
        """
        # first use the default configuration
        self._config.readfp(BytesIO(__default_config__))
        # now try to load the configuration file
        self.sync()

    def sync(self, ):
        """
        save configuration
        """
        with open(self._config_path, 'w') as config_file:
            config_file.truncate()
            self._config.write(config_file)

    def get(self, section, key, adapter = None, default = None):
        """
        get value of setting
        Arguments:
        - `section`: section name
        - `key`: key name
        - `adapter`: adapter function for type conversion
        - `default`: default value if the requested is not present
        """
        val = None
        try:
            val = self._config.get(section, key)
        except:
            if default:
                self.set(section, key, default, adapter)
                val = default
            else:
                raise KeyError

        # apply adapter if provided
        if adapter:
            val = adapter(val)

        return val

    def set(self, section, key, value, adapter = None):
        """
        set value of key in group
        Arguments:
        - `section`: section name
        - `key`: key
        - `value`: value to be saved
        - `adapter`: optional adapter to conver the value to a type that
        can be stringified
        """
        # add section it if does not exist
        if not self._config.has_section(section):
            self._config.add_section(section)
        # now store the value
        aval = None
        if adapter:
            aval = adapter(value)
        else:
            aval = value
        self._config.set(section, key, str(aval))

class Q3FileRes(object):
    """file resouce manager
    """
    
    def __init__(self, ):
        """
        """
        
        pass

    @staticmethod
    def _find_file_in_dirs(dirs_list, file_name):
        """Locate in one of directories, and return a full path to file.
        Raise Q3Error if file is not found
        """
        found_path = None

        for d in dirs_list:
            fp = os.path.join(d, file_name)
            if os.path.exists(fp):
                found_path = fp
                break

        if not found_path:
            raise Q3Error('resource file %s not found' % (file_name))

        return found_path

    @staticmethod
    def get_ui_file(file_name):
        """obtain path to .ui file
        """
        dirs = [DATA_DIR]
        if _in_source():
            dirs.append('.')
        
        return Q3FileRes._find_file_in_dirs(dirs, file_name)

    @staticmethod
    def get_icon_file(icon_name):
        """obtain path to icon file
        """
        dirs = [ICONS_DIR]
        if _in_source():
            dirs.append('.')
            
        return Q3FileRes._find_file_in_dirs(dirs, icon_name)

    @staticmethod
    def get_desktop_file(file_name):
        """obtain path to desktop file
        """
        dirs = [APPLICATIONS_DIR]
        if _in_source():
            dirs.append('./desktop')
            
        return Q3FileRes._find_file_in_dirs(dirs, file_name)


def _in_source():
    """indicate if running in source code directory
    """
    if os.getenv('IN_SOURCE'):
        return True
    return False
    
         
if __name__ == '__main__':
    app = Q3StatusApp()
    app.run()



